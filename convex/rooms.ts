import { mutation } from "./_generated/server";
import { ConvexError, v } from "convex/values";
import { query } from "./_generated/server";


export const createRoom = mutation({
  args: {
    name: v.string(),
    quiz: v.optional(v.object({
      title: v.string(),
      description: v.string(),
      numberOfQuestions: v.number(),
      questions: v.array(v.object({
        question: v.string(),
        explanation: v.string(),
        options: v.array(v.string()),
        correctAnswer: v.string(),
        points: v.optional(v.number()), // Optional points per question
        timeLimit: v.optional(v.number()), // Time limit in seconds
      }))
    })),
    settings: v.optional(v.object({
      maxParticipants: v.optional(v.number()),
      randomizeQuestions: v.optional(v.boolean()), // Future feature
      waitForAllAnswers: v.optional(v.boolean()), // Future maybe
    }))
  },
  handler: async (ctx, args) => {
    // Get the current user (assuming authentication is set up)
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Unauthorized");

    console.log("identity", identity);
    // Generate a unique ID for the room
    const newRoomID = crypto.randomUUID();

    // Create room
    await ctx.db.insert("rooms", {
      name: args.name,
      roomId: newRoomID,
      hostedBy: identity.name || "Unknown", // Name of the creator
      hostId: identity.subject, // User ID of the creator
      // participants: [{
      //   userId: identity.subject,
      //   imageUrl: identity.pictureUrl || "",
      //   email: identity.email || "",
      //   name: identity.name || "Unknown",
      //   score: 0,
      //   status: "ready",
      //   answers: []
      // }], // Creator is first participant
      status: "waiting", // Initial status
      quiz: args.quiz ?? { title: "",description:"", numberOfQuestions: 0, questions: [{ question: "", options: [""], explanation: "", correctAnswer: "", points: undefined, timeLimit: undefined }] },
      settings: args.settings ?? { maxParticipants: undefined, randomizeQuestions: undefined, waitForAllAnswers: undefined },
      startedAt: undefined,
      endedAt: undefined
    });

    return newRoomID; // Return the roomId generated by crypto.randomUUID()
  }
});

  export const getRoom = query({
    args: {
      roomId: v.string(),
    },
    handler: async (ctx, args) => {
      const room = await ctx.db.query("rooms").withIndex("byRoomId", q => q.eq("roomId", args.roomId)).unique();
      if (!room) {
        throw new Error("Room not found");
      }
      return room;
    },
  });

  export const getParticipantsInRoom= query({
    args: {
      roomId: v.string(),
    },
    handler: async (ctx, args) => {
      const room = await ctx.db.query("rooms").withIndex("byRoomId", q => q.eq("roomId", args.roomId)).unique();
      if (!room) {
        throw new Error("Room not found");
      }
      return room.participants;
    },
  });

  // export const joinRoom = mutation({
  //   args: {
  //     roomId: v.string()
  //   },
  //   handler: async (ctx, args) => {
  //     const identity = await ctx.auth.getUserIdentity();
  //     if (!identity) throw new Error("Unauthorized");
  
  //     // Find the room by roomId
  //     const room = await ctx.db.query("rooms")
  //       .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
  //       .unique();
  
  //     if (!room) throw new Error("Room not found");
  //     if (room.participants.includes(identity.subject)) {
  //       throw new Error("Already in room");
  //     }
  
  //     // Update participants list
  //     await ctx.db.patch(room._id, {
  //       participants: [...room.participants, identity.subject],
  //       updatedAt: Date.now()
  //     });
  
  //     return room.roomId; // Return the room's Convex document ID
  //   }
  // });