import { mutation } from "./_generated/server";
import { ConvexError, v } from "convex/values";
import { query } from "./_generated/server";

export const createRoom = mutation({
   handler: async (ctx) => {
    // Get the current user (assuming authentication is set up)
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Unauthorized");
    console.log("identity", identity);
    // Generate a unique ID for the room
    const newRoomID = crypto.randomUUID();
    // Create room
    await ctx.db.insert("rooms", {
      roomId: newRoomID,
      hostedBy: identity.name || "Unknown", // Name of the creator
      hostId: identity.subject, // User ID of the creator
      status: "waiting", // Initial status
    });
    return newRoomID; // Return the roomId generated by crypto.randomUUID()
  }
});

export const getRoom = query({
  args: {
    roomId: v.string(),
  },
  handler: async (ctx, args) => {
    const room = await ctx.db.query("rooms").withIndex("byRoomId", q => q.eq("roomId", args.roomId)).unique();
    if (!room) {
      throw new Error("Room not found");
    }
    return room;
  },
});

export const getParticipantsInRoom = query({
  args: {
    roomId: v.string(),
  },
  handler: async (ctx, args) => {
    const room = await ctx.db.query("rooms").withIndex("byRoomId", q => q.eq("roomId", args.roomId)).unique();
    if (!room) {
      throw new Error("Room not found");
    }
    return room.participants;
  },
});

export const joinRoom = mutation({
  args: {
    roomId: v.string()
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    // Find the room by roomId
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");
    console.log("room", room);
    console.log("identity", identity);
    if ((room.participants?.length ?? 0) >= (room.settings?.maxParticipants ?? Infinity)) {
      throw new Error("Room is full");
    }
    if (room.status !== "waiting") {
      throw new Error("Room is not accepting participants");
    }
    if (room.participants?.some(participant => participant.userId === identity.subject)) {
      return room.roomId; // Return the room's Convex document ID
    }
    // Add the user to the participants list
    await ctx.db.patch(room._id, {
      participants: [...(room.participants ?? []), {
        userId: identity.subject,
        imageUrl: identity.pictureUrl || "",
        email: identity.email || "",
        name: identity.name || "Unknown",
        score: 0,
        status: "ready",
        timeToAnswer: [0],
      }],
    });
    return room.roomId; // Return the room's Convex document ID
  }
});

export const leaveRoom = mutation({
  args: {
    roomId: v.string()
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    // Find the room by roomId
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");

    // Remove the user from the participants list
    const updatedParticipants = room.participants?.filter(participant => participant.userId !== identity.subject) ?? [];

    await ctx.db.patch(room._id, {
      participants: updatedParticipants,
    });

    return room.roomId; // Return the room's Convex document ID
  }
});

export const updateQuizInfoInRoom = mutation({
  args: {
    roomId: v.string(),
    status: v.literal("waiting"),
    givenfiles: v.optional(v.array(v.object({
    url: v.string(),
    size: v.number(),
    fileName: v.string(),
    extension: v.string(),
    mimeType: v.optional(v.string())
  }))),
    quiz: v.object({
      title: v.string(),
      description: v.string(),
      numberOfQuestions: v.number(),
      category: v.optional(v.string()),
      questions: v.array(v.object({
        question: v.string(),
        explanation: v.string(),
        options: v.array(v.string()),
        correctAnswer: v.string(),
        points: v.optional(v.number()), // Optional points per question
        timeLimit: v.optional(v.number()), // Time limit in seconds
      }))
    }),
    settings: v.optional(v.object({
      maxParticipants: v.number(),
      randomizeQuestions: v.boolean(),
      waitForAllAnswers: v.boolean(),
    }),
    )
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Unauthorized");

    // Find the room by roomId
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");

    if (room.hostId !== identity.subject) {
      throw new Error("Only the host can update the quiz info");
    }

    await ctx.db.patch(room._id, {
      quiz: args.quiz,
      givenfiles: args.givenfiles,
      settings: args.settings,
    });

    return room.roomId; // Return the room's Convex document ID
  }
});

export const updateRoomStatus = mutation({
  args: {
    roomId: v.string(),
  status: v.union(
    v.literal("in-progress"),
    v.literal("completed"),
  ),
},
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Unauthorized");

    // Find the room by roomId
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");

    // if (room.hostId !== identity.subject) {
    //   throw new Error("Only the host can update the room status");
    // }

    await ctx.db.patch(room._id, {
      status: args.status,
    });

    return room.roomId; // Return the room's Convex document ID
  }
});

export const getQuizQuetsions = query({
  args: { roomId: v.string() },
  handler: async (ctx, args) => {
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");

    return room.quiz?.questions;
  }
});

export const updateParticipant = mutation({
  args: {
    roomId: v.string(),
    status: v.union(
      v.literal("playing"),
      v.literal("finished"),
      v.literal("left"),
    ),
    score: v.optional(v.number()),
    timeTaken: v.optional(v.array(v.number())),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Unauthorized");

    // Find the room by roomId
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");

    const updatedParticipants = room.participants?.map(participant => {
      if (participant.userId === identity.subject) {
        return { 
          ...participant, 
          status: args.status,
          score: args.score ?? participant.score,
          timeToAnswer: args.timeTaken ?? participant.timeToAnswer,
        };
      }
      return participant;
    }) ?? [];

    await ctx.db.patch(room._id, {
      participants: updatedParticipants,
    });

    return room.roomId; // Return the room's Convex document ID
  }
});

export const getTopParticipants = query({
  args: { roomId: v.string() },
  handler: async (ctx, args) => {
    const room = await ctx.db.query("rooms")
      .withIndex("byRoomId", q => q.eq("roomId", args.roomId))
      .unique();

    if (!room) throw new Error("Room not found");

    const sortedParticipants = room.participants?.sort((a, b) => {
      const scoreDiff = (b.score ?? 0) - (a.score ?? 0);
      if (scoreDiff !== 0) return scoreDiff;

      const timeLengthDiff = (b.timeToAnswer?.length ?? 0) - (a.timeToAnswer?.length ?? 0);
      if (timeLengthDiff !== 0) return timeLengthDiff;

      const sumTimeA = (a.timeToAnswer ?? []).reduce((sum, time) => sum + time, 0);
      const sumTimeB = (b.timeToAnswer ?? []).reduce((sum, time) => sum + time, 0);
      return sumTimeA - sumTimeB;
    }) ?? [];
    return sortedParticipants;
  }
});